snippet	asncd
	assert_not_const_defined ${1:object}, ${2:constant_name}
snippet	asnid
	assert_not_in_delta ${1:expected_float}, ${2:actual_float}
snippet	fileeach
	File.foreach(${1:"<+path}"+>) { |${2:line}| ${3} }
snippet	while
	while ${1:condition}
		${2}
	end
snippet	asnem
	assert_not_empty ${1:object}
snippet	asnt
	assert_nothing_thrown { ${1} }
snippet	fopen
	File.open(${1:path}, "${2:rwab}") { |${3:file}| ${4} }
snippet	detecto
	detect do |${1:element}|
		${2:body}
	end
snippet	asie
	assert_in_epsilon ${1:expected_float}, ${2:actual_float}
snippet	eado
	each do |${1:element}|
		${2:body}
	end
snippet	bm
	TESTS = ${1:10_000}
	Benchmark.bmbm do |results|
		${2}
	end
snippet	asko
	assert_kind_of ${1:ExpectedKind}, ${2:actual_instance}
snippet	asem
	assert_empty ${1:object}
snippet	aso
	assert_operator ${1:left}, :${2:operator}, ${3:right}
snippet	each
	each { |${1:element}| ${2:body} }
snippet	case
	case ${1}
	when ${2}
	else
		${3}
	end
snippet	tc
	require "test/unit"

	require "${1:library_file_name}"

	class Test${2:`Snippet_RubyClassNameFromFilename()`} < Test::Unit::TestCase
		def test_${3:case_name}
			${4}
		end
	end
snippet	reject
	reject { |${1:element}| ${2:body} }
snippet	http_get
	require 'net/http'
	res = Net::HTTP.get URI.parse('${1:url}')
snippet	deft
	def test_${1:case_name}
		${2}
	end
snippet	detect
	detect { |${1:element}| ${2:body} }
snippet	tas
	desc "${1:Task description}"
	task :${2:task_name}${3: => [:dependent, :tasks]} do
		${4}
	end
snippet	xpa
	elements.each(${1}) do |${2:node}|
		${3}
	end
snippet	dglob
	Dir.glob(${1:"<+dir}"+>) { |${2:file}| ${3} }
snippet	injdo
	inject(${1:init}) do |${2:total}, ${3:next}|
		${4:body}
	end
snippet	fread
	File.read(${1})
snippet	astr
	assert_true ${1:actual}
snippet	as
	assert ${1:test}, "${2:failure_message}"
snippet	eawi
	each_with_index { |${1:element},${2:i}| ${3:} }
snippet	ife
	if ${1:condition}
		${2}
	else
	end
snippet	Md
	File.open(${1:dump_path}, "wb") { |${2:file}| Marshal.dump(${3:obj}, ${4:$2}) }
snippet	asnse
	assert_not_send ${1:send_array}
snippet	ope
	open(${1:path}, "${2:rwab}") { |${3:io}| ${4} }
snippet	asrko
	assert_raise_kind_of(${1:kinds...}) { ${2:block} }
snippet	ip
	ip_addr = request.env['REMOTE_ADDR']
snippet	http_post
	require 'net/http'
	res = Net::HTTP.post_form URI.parse('${1:url}')${2:, params}
snippet	nam
	namespace :${1:namespace} do
		${2}
	end
snippet	mapo
	map do |${1:element}|
		${2:body}
	end
snippet	asfa
	assert_fail_assertion { ${1:block} }
snippet	asni
	assert_not_include ${1:collection}, ${2:object}
snippet	mapdo
	map do |${1:element}|
		${2:body}
	end
snippet	zip
	zip(${1:enums}) { |${2:row}| ${3} }
snippet	eacho
	each do |${1:element}|
		${2:body}
	end
snippet	inj
	inject(${1:init}) { |${2:total}, ${3:next}| ${4:body} }
snippet	asn
	assert_nil ${1:instance}
snippet	defi
	def initialize${1}
		${2}
	end
snippet	defmm
	def method_missing(meth, *args, &blk)
		${1}
	end
snippet	dop
	do |${1:param}|
		${2}
	end
snippet	w
	attr_writer :${1:attr_names}
snippet	ast
	assert_throws(:${1:expected}) { ${2} }
snippet	asf
	assert_false ${1:actual}
snippet	mod
	module ${1:`Snippet_RubyClassNameFromFilename()`}
		${2}
	end
snippet	asnp
	assert_not_predicate ${1:object}, ${2:predicate}
snippet	r
	attr_reader :${1:attr_names}
snippet	unless
	unless ${1:condition}
		${2}
	end
snippet	aspe
	assert_path_exist ${1:path}
snippet	select
	select { |${1:element}| ${2:body} }
snippet	each_with_index
	each_with_index { |${1:element},${2:i}| ${3:} }
snippet	asr
	assert_raise(${1:Exception}) { ${2} }
snippet	asio
	assert_instance_of ${1:ExpectedClass}, ${2:actual_instance}
snippet	class
	class ${1:`Snippet_RubyClassNameFromFilename()`}${2}
		${3}
	end
snippet	asm
	assert_match /${1:expected_pattern}/, ${2:actual_string}
snippet	asnm
	assert_no_match /${1:unexpected_pattern}/, ${2:actual_string}
snippet	do
	do
		${1}
	end
snippet	asne
	assert_not_equal ${1:unexpected}, ${2:actual}
snippet	Yl
	File.open(${1:path_to_yml}) { |${2:file}| YAML.load(${3:$2}) }
snippet	sort
	sort { |${1:x},${2:y}| ${3:body} }
snippet	sinc
	class << self; self end
snippet	asnr
	assert_nothing_raised { ${1:block} }
snippet	pathhere
	File.join(File.dirname(__FILE__), *%w[${1:rel_path_here}])
snippet	def
	def ${1:name}
		${2}
	end
snippet	asi
	assert_include ${1:collection}, ${2:object}
snippet	Pn
	PStore.new(${1})
snippet	task
	desc "${1:Task description}"
	task :${2:task_name}${3: => [:dependent, :tasks]} do
		${4}
	end
snippet	sorto
	sort do |${1:x},${2:y}|
		${3:body}
	end
snippet	asse
	assert_send ${1:send_array}
snippet	defs
	def self.${1:class_method_name}
		${2}
	end
snippet	module
	module ${1:`Snippet_RubyClassNameFromFilename()`}
		module ClassMethods
			${2}
		end

		module InstanceMethods

		end

		def self.included(receiver)
			receiver.extend         ClassMethods
			receiver.send :include, InstanceMethods
		end
	end
snippet	injecto
	inject do |${1:total},${2:next}|
		${3:body}
	end
snippet	selecto
	select do |${1:element}|
		${2:body}
	end
snippet	asns
	assert_not_same ${1:unexpected}, ${2:actual}
snippet	asp
	assert_predicate ${1:object}, ${2:predicate}
snippet	if
	if ${1:condition}
		${2}
	end
snippet	Ml
	File.open(${1:dump_path}, "rb") { |${2:file}| Marshal.load(${3:$2}) }
snippet	asnrt
	assert_not_respond_to ${1:object}, ${2:method}
snippet	each_with_indexo
	each_with_index do |${1:element},${2:i}|
		${3:body}
	end

snippet	am
	alias_method :${1:new_name}, :${2:old_name}
snippet	elsif
	elsif ${1:condition}
		${2}
snippet	rejecto
	reject do |${1:element}|
		${2:body}
	end
snippet	asc
	assert_compare ${1:expected}, ${2:operator}, ${3:actual}
snippet	Yd
	File.open(${1:path_to_yml}, "w") { |${2:file}| YAML.dump(${3:obj}, ${4:$2}) }
snippet	asnie
	assert_not_in_epsilon ${1:expected_float}, ${2:actual_float}
snippet	ase
	assert_equal ${1:expected}, ${2:actual}
snippet	unlesse
	unless ${1:condition}
		${2}
	else
	end
snippet	ascd
	assert_const_defined ${1:object}, ${2:constant_name}
snippet	xmlr
	REXML::Document.new(File.read(${1:path}))
snippet	asid
	assert_in_delta ${1:expected_float}, ${2:actual_float}, ${3:delta_float}
snippet	asb
	assert_boolean ${1:actual}
snippet	rw
	attr_accessor :${1:attr_names}
snippet	asrt
	assert_respond_to ${1:object}, :${2:method}
snippet	classe
	class ${1:ErrorClassName} < ${2:StandardError}; end${3}
snippet	asnn
	assert_not_nil ${1:instance}
snippet	map
	map { |${1:element}| ${2:body} }
snippet	inject
	inject { |${1:total},${2:next}| ${3:body} }
snippet	ea
	each { |${1:element}| ${2:body} }
snippet	aspne
	assert_path_not_exist ${1:path}
snippet	asrm
	assert_raise_message ${1:expected_message}
snippet	eawido
	each_with_index do |${1:element},${2:i}|
		${3:body}
	end

snippet	rep
	results.report("${1:name}:") { TESTS.times { ${2} } }
snippet	asam
	assert_alias_method ${1:object}, ${2:alias_name}, ${3:original_name}
snippet		vagrant_forwarded_port
alias		vagrantforwardedport forwardedport
options		head
prev_word	'^'
	config.vm.network "forwarded_port", guest: 80, host: 10080
snippet		provision
options		head
prev_word	'^'
	config.vm.provision :shell, :inline => "${0:}"
